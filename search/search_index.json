{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcda SdamGIA API","text":"<p>Unofficial API for SdamGIA educational portal for exam preparation written in Python.</p>"},{"location":"#important-note","title":"\u26a0\ufe0f Important Note","text":"<p>This library retrieves data by parsing HTML because sdamgia uses server-side rendering, which is not very reliable, but the only method available at the moment. We strive to keep the API up to date to work as expected. However, if you encounter any issues, please report them.</p> <p>Use of this library is at your own risk. Sdamgia explicitly restricts parsing, and we do not take responsibility for any legal issues that arise from using this library.</p>"},{"location":"#installing","title":"\ud83d\udce6 Installing","text":"<p>Python 3.10 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>pip install -U sdamgia\n</code></pre> <p>For full problem text recognition support <code>pix2tex</code> extra is required, which can be installed like so:</p> <pre><code>pip install -U \"sdamgia[pix2tex]\"\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add the library as a dependency like so:</p> <pre><code>poetry add sdamgia\n</code></pre> <p>With full text recognition support:</p> <pre><code>poetry add sdamgia --extras pix2tex\n</code></pre>"},{"location":"#problems-database-structure","title":"\ud83d\uddc2\ufe0f Problems database structure","text":"<p>To make it easier to understand how the SdamGIA problems database is structured, I suggest using the following scheme:</p> <pre><code>SdamGIA\n\u2514\u2500\u2500 GIA type, Subject\n    \u251c\u2500\u2500 Problem catalog\n    \u2502   \u2514\u2500\u2500 Topic\n    \u2502       \u2514\u2500\u2500 Category\n    \u2502           \u2514\u2500\u2500 Problem\n    \u2514\u2500\u2500 Test\n        \u2514\u2500\u2500 Problem\n</code></pre> <p>Each problem, test, theme or category has its own unique integer ID.</p>"},{"location":"#documentation","title":"\ud83d\udcc3 Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#basic-usage","title":"\ud83d\ude80 Basic usage","text":"<p>Because SdamgiaAPI client is asynchronous, it needs to be initialized in asynchronous context:</p> <pre><code>import asyncio\nimport dataclasses\nimport json\n\nfrom sdamgia import SdamgiaAPI\nfrom sdamgia.types import Problem\nfrom sdamgia.enums import GiaType, Subject\n\n\ndef problem_to_json(problem: Problem) -&gt; str:\n    return json.dumps(dataclasses.asdict(problem), indent=4, ensure_ascii=False)\n\n\nasync def main() -&gt; None:\n    async with SdamgiaAPI(gia_type=GiaType.EGE, subject=Subject.MATH) as sdamgia:\n        problem_id = 26596\n        problem = await sdamgia.get_problem(problem_id, subject=Subject.MATH)\n        print(problem_to_json(problem))\n        print(problem.url)  # https://math-ege.sdamgia.ru/problem?id=26596\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Or without context manager:</p> <pre><code>from sdamgia import SdamgiaAPI\nfrom sdamgia.enums import GiaType, Subject\n\n\nasync def main() -&gt; None:\n    sdamgia = SdamgiaAPI(gia_type=GiaType.EGE, subject=Subject.MATH)\n    # ... do something with client\n    await sdamgia.close()  # this line is mandatory\n</code></pre>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project is licensed under the LGPLv3+ license - see the license file for details.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#sdamgia.api.SdamgiaAPI","title":"SdamgiaAPI","text":"<pre><code>SdamgiaAPI(gia_type: GiaType = GiaType.EGE, subject: Subject = Subject.MATH, *, session: ClientSession | None = None)\n</code></pre> <p>Interface for SdamGIA public API.</p> <p>Note</p> <p>Every public method of this class has <code>gia_type</code> and <code>subject</code> parameters, which can overwrite ones set on initialization. Those parameters are handled with a special decorator and so do not have type hints.</p> <p>Parameters:</p> Name Type Description Default <code>gia_type</code> <code>GiaType</code> <p>The GIA type to use in methods if unspecified.</p> <code>EGE</code> <code>subject</code> <code>Subject</code> <p>The subject to use in methods if unspecified.</p> <code>MATH</code> <code>session</code> <code>ClientSession | None</code> <p>An aiohttp client session to use for requests.</p> <code>None</code> Source code in <code>sdamgia/api.py</code> <pre><code>def __init__(\n    self,\n    gia_type: GiaType = GiaType.EGE,\n    subject: Subject = Subject.MATH,\n    *,\n    session: aiohttp.ClientSession | None = None,\n):\n    self.gia_type = gia_type\n    self.subject = subject\n    self._session = session or aiohttp.ClientSession()\n    self._latex_ocr_model = None\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: str\n</code></pre> <p>Get base site url for currently used GIA type and subject.</p>"},{"location":"api/#sdamgia.api.SdamgiaAPI.get_problem","title":"get_problem  <code>async</code>","text":"<pre><code>get_problem(problem_id: int, recognize_text: bool = False) -&gt; Problem\n</code></pre> <p>Fetch a problem by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>problem_id</code> <code>int</code> <p>The ID of the problem to Fetch.</p> required <code>recognize_text</code> <code>bool</code> <p>Whether to perform LaTeX OCR on the problem text. Requires \"pix2tex\" extra.</p> <code>False</code> <p>Returns:</p> Type Description <code>Problem</code> <p>The problem fetched.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def get_problem(\n    self,\n    problem_id: int,\n    recognize_text: bool = False,\n) -&gt; Problem:\n    \"\"\"Fetch a problem by its ID.\n\n    Args:\n        problem_id: The ID of the problem to Fetch.\n        recognize_text: Whether to perform LaTeX OCR on the problem text.\n            Requires \"pix2tex\" extra.\n\n    Returns:\n        The problem fetched.\n    \"\"\"\n    parser = HTMLParser(await self._get(f\"/problem?id={problem_id}\"))\n\n    if (problem_node := parser.css_first(\".prob_maindiv\")) is None:\n        raise RuntimeError(\"Problem node not found\")\n\n    # make all image urls absolute\n    for img_node in problem_node.css(\"img\"):\n        if BASE_DOMAIN not in (url := str(img_node.attributes[\"src\"])):\n            img_node.attributes[\"src\"] = urljoin(self.base_url, url)\n\n    try:\n        topic_id = int(problem_node.css_first(\"span.prob_nums\").text().split()[1])\n    except (IndexError, AttributeError, ValueError):\n        topic_id = None\n\n    try:\n        condition_node = parser.css_first(\"div.pbody\")\n        condition = await self._get_problem_part(condition_node, recognize_text=recognize_text)\n    except (IndexError, AttributeError):\n        condition = None\n\n    try:\n        solution_node = (\n            problem_node.css_first(\"div.solution\") or problem_node.css(\"div.pbody\")[1]\n        )\n        solution = await self._get_problem_part(solution_node, recognize_text=recognize_text)\n    except (IndexError, AttributeError):\n        solution = None\n\n    try:\n        answer = problem_node.css_first(\"div.answer\").text().lstrip(\"\u041e\u0442\u0432\u0435\u0442:\").strip()\n    except (IndexError, AttributeError):\n        answer = \"\"\n\n    analog_urls = [\n        str(link.attributes[\"href\"]) for link in problem_node.css_first(\"div.minor\").css(\"a\")\n    ]\n    analog_ids = [\n        int(mo.group(1)) for url in analog_urls if (mo := re.search(r\"id=(\\d+)\", url))\n    ]\n\n    return Problem(\n        gia_type=self.gia_type,\n        subject=self.subject,\n        id=problem_id,\n        condition=condition,\n        solution=solution,\n        answer=answer,\n        topic_id=topic_id,\n        analog_ids=analog_ids,\n    )\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.search","title":"search  <code>async</code>","text":"<pre><code>search(query: str) -&gt; list[int]\n</code></pre> <p>Search problems by search query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query to use.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A list of IDs of problems what match search query.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def search(self, query: str) -&gt; list[int]:\n    \"\"\"Search problems by search query.\n\n    Args:\n        query: The search query to use.\n\n    Returns:\n        A list of IDs of problems what match search query.\n    \"\"\"\n    return await self._get_problem_ids_pagination(\"/search\", params={\"search\": query})\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.get_theme","title":"get_theme  <code>async</code>","text":"<pre><code>get_theme(theme_id: int) -&gt; list[int]\n</code></pre> <p>Fetch a category theme by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>theme_id</code> <code>int</code> <p>The ID of the theme to Fetch.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A list of IDs of problems included in the theme.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def get_theme(self, theme_id: int) -&gt; list[int]:\n    \"\"\"Fetch a category theme by its ID.\n\n    Args:\n        theme_id: The ID of the theme to Fetch.\n\n    Returns:\n        A list of IDs of problems included in the theme.\n    \"\"\"\n    return await self._get_problem_ids_pagination(\"/test\", params={\"theme\": theme_id})\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.get_test","title":"get_test  <code>async</code>","text":"<pre><code>get_test(test_id: int) -&gt; list[int]\n</code></pre> <p>Fetch a test by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>test_id</code> <code>int</code> <p>The ID of the test to Fetch.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>A list of IDs of problem included in the test.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def get_test(self, test_id: int) -&gt; list[int]:\n    \"\"\"Fetch a test by its ID.\n\n    Args:\n        test_id: The ID of the test to Fetch.\n\n    Returns:\n        A list of IDs of problem included in the test.\n    \"\"\"\n    parser = HTMLParser(await self._get(f\"/test?id={test_id}\"))\n    return self._get_problem_ids(parser)\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.get_catalog","title":"get_catalog  <code>async</code>","text":"<pre><code>get_catalog() -&gt; Catalog\n</code></pre> <p>Fetch a subject catalog.</p> <p>Returns:</p> Type Description <code>Catalog</code> <p>A list of topics containing included categories.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def get_catalog(self) -&gt; Catalog:\n    \"\"\"Fetch a subject catalog.\n\n    Returns:\n        A list of topics containing included categories.\n    \"\"\"\n    parser = HTMLParser(await self._get(\"/prob_catalog\"))\n    topics = [c for c in parser.css(\"div.cat_category\") if c.attributes.get(\"data-id\") is None]\n    topics = topics[1:]  # skip header\n\n    catalog = []\n    for topic in topics:\n        topic_id_str, topic_name = topic.css_first(\"b.cat_name\").text().split(\".\", maxsplit=1)\n        topic_name = topic_name.strip()\n        is_additional = \"\u0434\" in topic_id_str.lower()\n        topic_number = int(re.search(r\"\\d+\", topic_id_str).group())  # type: ignore[union-attr]\n        categories = [\n            Category(\n                id=int(str(cat_node.attributes.get(\"data-id\", -1))),\n                name=cat_node.css_first(\"a.cat_name\").text(),\n                problems_count=int(cat_node.css_first(\"div.cat_count\").text()),\n                gia_type=self.gia_type,\n                subject=self.subject,\n            )\n            for cat_node in topic.css_first(\"div.cat_children\").css(\"div.cat_category\")\n        ]\n\n        catalog.append(\n            Topic(\n                number=topic_number,\n                name=topic_name,\n                is_additional=is_additional,\n                categories=categories,\n                gia_type=self.gia_type,\n                subject=self.subject,\n            )\n        )\n\n    return catalog\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.generate_test","title":"generate_test  <code>async</code>","text":"<pre><code>generate_test(problems: dict[int | Literal['full'], int] | None = None) -&gt; int\n</code></pre> <p>Generate a test with a specified number of problems from selected categories.</p> <p>If none are passed, generates a test with one problem from each category.</p> <p>Parameters:</p> Name Type Description Default <code>problems</code> <code>dict[int | Literal['full'], int] | None</code> <p>A dictionary specifying the number of problems to include for each category. Should be formatted as follows: <code>{&lt;category id&gt;: &lt;problems count&gt;, ... }</code>.</p> <p>Alternatively, you can specify the same number of problems for each category: <code>{'full': &lt;problems count&gt;}</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The generated test ID.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def generate_test(self, problems: dict[int | Literal[\"full\"], int] | None = None) -&gt; int:\n    \"\"\"Generate a test with a specified number of problems from selected categories.\n\n    If none are passed, generates a test with one problem from each category.\n\n    Args:\n        problems: A dictionary specifying the number of problems to include for each category.\n            Should be formatted as follows: `{&lt;category id&gt;: &lt;problems count&gt;, ... }`.\n\n            Alternatively, you can specify the same number of problems for each category:\n            `{'full': &lt;problems count&gt;}`.\n\n    Returns:\n        The generated test ID.\n    \"\"\"\n    if not problems:\n        problems = {\"full\": 1}\n\n    if total := problems.get(\"full\"):\n        params = {f\"prob{i + 1}\": total for i in range(len(await self.get_catalog()))}\n    else:\n        params = {f\"prob{i}\": problems[i] for i in problems}\n\n    path = (\n        await self._session.get(\n            f\"{self.base_url}/test?a=generate\",\n            params=params,\n            allow_redirects=False,\n        )\n    ).headers[\"location\"]\n    return int(re.search(r\"id=(\\d+)\", path).group(1))  # type: ignore[union-attr]\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.generate_pdf","title":"generate_pdf  <code>async</code>","text":"<pre><code>generate_pdf(test_id: int, *, solutions: bool = False, problem_ids: bool = False, answers: bool = False, answers_table: bool = False, criteria: bool = False, instruction: bool = False, footer: str = '', title: str = '', pdf_type: Literal['h', 'z', 'm', 'true'] = 'true') -&gt; str\n</code></pre> <p>Generates a PDF version of the test.</p> <p>Parameters:</p> Name Type Description Default <code>test_id</code> <code>int</code> <p>The identifier of the test.</p> required <code>solutions</code> <code>bool</code> <p>Include explanations.</p> <code>False</code> <code>problem_ids</code> <code>bool</code> <p>Include problem numbers.</p> <code>False</code> <code>answers</code> <code>bool</code> <p>Include answers.</p> <code>False</code> <code>answers_table</code> <code>bool</code> <p>Include answer key.</p> <code>False</code> <code>criteria</code> <code>bool</code> <p>Include criteria.</p> <code>False</code> <code>instruction</code> <code>bool</code> <p>Include instruction.</p> <code>False</code> <code>footer</code> <code>str</code> <p>The text for the footer.</p> <code>''</code> <code>title</code> <code>str</code> <p>The title of the test.</p> <code>''</code> <code>pdf_type</code> <code>Literal['h', 'z', 'm', 'true']</code> <p>The type of the generated PDF document.</p> <p>\"h\" - version with large margins. \"z\" - version with large font. \"m\" - horizontal version. \"true\" - normal version (default).</p> <code>'true'</code> <p>Returns:</p> Type Description <code>str</code> <p>The URL of the generated PDF document.</p> Source code in <code>sdamgia/api.py</code> <pre><code>@_handle_params\nasync def generate_pdf(\n    self,\n    test_id: int,\n    *,\n    solutions: bool = False,\n    problem_ids: bool = False,\n    answers: bool = False,\n    answers_table: bool = False,\n    criteria: bool = False,\n    instruction: bool = False,\n    footer: str = \"\",\n    title: str = \"\",\n    pdf_type: Literal[\"h\", \"z\", \"m\", \"true\"] = \"true\",\n) -&gt; str:\n    \"\"\"Generates a PDF version of the test.\n\n    Args:\n        test_id: The identifier of the test.\n        solutions: Include explanations.\n        problem_ids: Include problem numbers.\n        answers: Include answers.\n        answers_table: Include answer key.\n        criteria: Include criteria.\n        instruction: Include instruction.\n        footer: The text for the footer.\n        title: The title of the test.\n        pdf_type: The type of the generated PDF document.\n\n            \"h\" - version with large margins.\n            \"z\" - version with large font.\n            \"m\" - horizontal version.\n            \"true\" - normal version (default).\n\n    Returns:\n        The URL of the generated PDF document.\n    \"\"\"\n\n    def _format(var: bool) -&gt; str:\n        return \"true\" if var else \"\"\n\n    params = {\n        \"id\": test_id,\n        \"print\": \"true\",\n        \"pdf\": pdf_type,\n        \"sol\": _format(solutions),\n        \"num\": _format(problem_ids),\n        \"ans\": _format(answers),\n        \"key\": _format(answers_table),\n        \"crit\": _format(criteria),\n        \"pre\": _format(instruction),\n        \"dcol\": footer,\n        \"tt\": title,\n    }\n    for key, value in params.copy().items():\n        if not value:\n            del params[key]\n\n    return urljoin(\n        self.base_url,\n        (\n            await self._session.get(\n                f\"{self.base_url}/test\", params=params, allow_redirects=False\n            )\n        ).headers[\"location\"],\n    )\n</code></pre>"},{"location":"api/#sdamgia.api.SdamgiaAPI.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close current session.</p> Source code in <code>sdamgia/api.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close current session.\"\"\"\n    await self._session.close()\n</code></pre>"},{"location":"enums/","title":"Enums","text":""},{"location":"enums/#sdamgia.enums.GiaType","title":"GiaType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Represents GIA types.</p>"},{"location":"enums/#sdamgia.enums.Subject","title":"Subject","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Represents subject types.</p>"},{"location":"types/","title":"Types","text":""},{"location":"types/#sdamgia.types.Catalog","title":"Catalog  <code>module-attribute</code>","text":"<pre><code>Catalog: TypeAlias = list[Topic]\n</code></pre> <p>Represents problems catalog.</p>"},{"location":"types/#sdamgia.types.BaseType","title":"BaseType  <code>dataclass</code>","text":"<pre><code>BaseType(gia_type: GiaType, subject: Subject)\n</code></pre> <p>A base class for SdamGIA types.</p>"},{"location":"types/#sdamgia.types.ProblemPart","title":"ProblemPart  <code>dataclass</code>","text":"<pre><code>ProblemPart(text: str, html: str, image_urls: list[str])\n</code></pre> <p>Represents problem part (condition or solution).</p>"},{"location":"types/#sdamgia.types.Problem","title":"Problem  <code>dataclass</code>","text":"<pre><code>Problem(gia_type: GiaType, subject: Subject, id: int, condition: ProblemPart | None, solution: ProblemPart | None, answer: str, topic_id: int | None, analog_ids: list[int])\n</code></pre> <p>               Bases: <code>BaseType</code></p> <p>Represents problem.</p>"},{"location":"types/#sdamgia.types.Problem.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL of the problem.</p>"},{"location":"types/#sdamgia.types.Category","title":"Category  <code>dataclass</code>","text":"<pre><code>Category(gia_type: GiaType, subject: Subject, id: int, name: str, problems_count: int)\n</code></pre> <p>               Bases: <code>BaseType</code></p> <p>Represents problems category.</p>"},{"location":"types/#sdamgia.types.Category.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL of the category.</p>"},{"location":"types/#sdamgia.types.Topic","title":"Topic  <code>dataclass</code>","text":"<pre><code>Topic(gia_type: GiaType, subject: Subject, number: int, name: str, is_additional: bool, categories: list[Category])\n</code></pre> <p>               Bases: <code>BaseType</code></p> <p>Represents problems topic.</p>"},{"location":"types/#sdamgia.types.Topic.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL of the topic.</p>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#sdamgia.utils.base_url","title":"base_url","text":"<pre><code>base_url(gia_type: GiaType, subject: Subject) -&gt; str\n</code></pre> <p>Create base url for certain GIA type and subject.</p> Source code in <code>sdamgia/utils.py</code> <pre><code>def base_url(gia_type: GiaType, subject: Subject) -&gt; str:\n    \"\"\"Create base url for certain GIA type and subject.\"\"\"\n    return _base_url(gia_type=gia_type, subject=subject)\n</code></pre>"},{"location":"utils/#sdamgia.utils.create_pdf_from_html","title":"create_pdf_from_html","text":"<pre><code>create_pdf_from_html(html: str, output_file_path: str) -&gt; None\n</code></pre> <p>Create a PDF file from HTML content.</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>The HTML content from which the PDF will be generated.</p> required <code>output_file_path</code> <code>str</code> <p>The path to save the generated PDF file.</p> required Source code in <code>sdamgia/utils.py</code> <pre><code>def create_pdf_from_html(html: str, output_file_path: str) -&gt; None:\n    \"\"\"Create a PDF file from HTML content.\n\n    Args:\n        html: The HTML content from which the PDF will be generated.\n        output_file_path: The path to save the generated PDF file.\n    \"\"\"\n    subprocess.Popen(\n        [\n            \"/usr/bin/pandoc\",\n            \"-\",\n            \"-f\",\n            \"html\",\n            \"-o\",\n            output_file_path,\n            \"-t\",\n            \"latex\",\n            \"-V\",\n            \"fontenc=T2A\",\n        ],\n        stdin=subprocess.PIPE,\n    ).communicate(input=f\"&lt;html&gt;&lt;body&gt;{html}&lt;/body&gt;&lt;/html&gt;\".encode())\n</code></pre>"},{"location":"utils/#sdamgia.utils.create_problem_pdf_html","title":"create_problem_pdf_html","text":"<pre><code>create_problem_pdf_html(problem: Problem) -&gt; None\n</code></pre> <p>Create a PDF file from HTML representation of a problem.</p> Source code in <code>sdamgia/utils.py</code> <pre><code>def create_problem_pdf_html(problem: Problem) -&gt; None:\n    \"\"\"Create a PDF file from HTML representation of a problem.\"\"\"\n    create_pdf_from_html(\n        html=f\"&lt;b&gt;\u0423\u0441\u043b\u043e\u0432\u0438\u0435:&lt;/b&gt;{problem.condition.html}{problem.solution.html}\",  # type: ignore[union-attr]\n        output_file_path=f\"{problem.subject}-{problem.gia_type}-{problem.id}.pdf\",\n    )\n</code></pre>"},{"location":"utils/#sdamgia.utils.create_problem_pdf_tex","title":"create_problem_pdf_tex","text":"<pre><code>create_problem_pdf_tex(problem: Problem) -&gt; None\n</code></pre> <p>Create a PDF file from LaTeX representation of a problem.</p> Source code in <code>sdamgia/utils.py</code> <pre><code>def create_problem_pdf_tex(problem: Problem) -&gt; None:\n    \"\"\"Create a PDF file from LaTeX representation of a problem.\"\"\"\n    tex = (\n        \"\\\\documentclass{article}\\n\"\n        \"\\\\usepackage[T2A]{fontenc}\\n\\\\usepackage[utf8]{inputenc}\\n\"\n        \"\\\\usepackage[russian,english]{babel}\\n\"\n        \"\\\\usepackage{amsmath}\\n\\\\usepackage{amssymb}\\n\"\n        \"\\\\usepackage{hyperref}\\n\\\\hypersetup{colorlinks=true,urlcolor=blue}\\n\\n\"\n        \"\\\\begin{document}\\n\"\n        f\"\\\\section{{\\\\href{{{problem.id}}}{{{problem.url}}}\\n\\n\"\n        \"\\\\subsection{\u0423\u0441\u043b\u043e\u0432\u0438\u0435:}\\n\\n\"\n        f\"{problem.condition.text}\\n\\n\"  # type: ignore[union-attr]\n        \"\\\\subsection{\u0420\u0435\u0448\u0435\u043d\u0438\u0435:}\\n\\n\"\n        f\"{problem.solution.text}\\n\\n\"  # type: ignore[union-attr]\n        \"\\\\end{document}\"\n    )\n\n    temp_file_path = f\"{problem.id}-{problem.subject}.tex\"\n    pdf_file_path = temp_file_path.replace(\".tex\", \".pdf\")\n    with open(temp_file_path, \"w\") as f:\n        f.write(tex)\n    try:\n        subprocess.Popen([\"/usr/bin/pdflatex\", temp_file_path, \"-o\", pdf_file_path])\n    finally:\n        os.remove(temp_file_path)\n</code></pre>"}]}